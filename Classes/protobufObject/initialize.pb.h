// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: initialize.proto

#ifndef PROTOBUF_initialize_2eproto__INCLUDED
#define PROTOBUF_initialize_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_initialize_2eproto();
void protobuf_AssignDesc_initialize_2eproto();
void protobuf_ShutdownFile_initialize_2eproto();

class BINInitializeRequest;
class BINLevel;
class BINInitializeResponse;

// ===================================================================

class BINInitializeRequest : public ::google::protobuf::Message {
 public:
  BINInitializeRequest();
  virtual ~BINInitializeRequest();

  BINInitializeRequest(const BINInitializeRequest& from);

  inline BINInitializeRequest& operator=(const BINInitializeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BINInitializeRequest& default_instance();

  void Swap(BINInitializeRequest* other);

  // implements Message ----------------------------------------------

  BINInitializeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BINInitializeRequest& from);
  void MergeFrom(const BINInitializeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cp = 1;
  inline bool has_cp() const;
  inline void clear_cp();
  static const int kCpFieldNumber = 1;
  inline const ::std::string& cp() const;
  inline void set_cp(const ::std::string& value);
  inline void set_cp(const char* value);
  inline void set_cp(const char* value, size_t size);
  inline ::std::string* mutable_cp();
  inline ::std::string* release_cp();
  inline void set_allocated_cp(::std::string* cp);

  // optional string appVersion = 2;
  inline bool has_appversion() const;
  inline void clear_appversion();
  static const int kAppVersionFieldNumber = 2;
  inline const ::std::string& appversion() const;
  inline void set_appversion(const ::std::string& value);
  inline void set_appversion(const char* value);
  inline void set_appversion(const char* value, size_t size);
  inline ::std::string* mutable_appversion();
  inline ::std::string* release_appversion();
  inline void set_allocated_appversion(::std::string* appversion);

  // optional string deviceId = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 3;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // optional string deviceInfo = 4;
  inline bool has_deviceinfo() const;
  inline void clear_deviceinfo();
  static const int kDeviceInfoFieldNumber = 4;
  inline const ::std::string& deviceinfo() const;
  inline void set_deviceinfo(const ::std::string& value);
  inline void set_deviceinfo(const char* value);
  inline void set_deviceinfo(const char* value, size_t size);
  inline ::std::string* mutable_deviceinfo();
  inline ::std::string* release_deviceinfo();
  inline void set_allocated_deviceinfo(::std::string* deviceinfo);

  // optional string ipAddress = 5;
  inline bool has_ipaddress() const;
  inline void clear_ipaddress();
  static const int kIpAddressFieldNumber = 5;
  inline const ::std::string& ipaddress() const;
  inline void set_ipaddress(const ::std::string& value);
  inline void set_ipaddress(const char* value);
  inline void set_ipaddress(const char* value, size_t size);
  inline ::std::string* mutable_ipaddress();
  inline ::std::string* release_ipaddress();
  inline void set_allocated_ipaddress(::std::string* ipaddress);

  // optional string country = 6;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 6;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  inline void set_allocated_country(::std::string* country);

  // optional string language = 7;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 7;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // @@protoc_insertion_point(class_scope:BINInitializeRequest)
 private:
  inline void set_has_cp();
  inline void clear_has_cp();
  inline void set_has_appversion();
  inline void clear_has_appversion();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_deviceinfo();
  inline void clear_has_deviceinfo();
  inline void set_has_ipaddress();
  inline void clear_has_ipaddress();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_language();
  inline void clear_has_language();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cp_;
  ::std::string* appversion_;
  ::std::string* deviceid_;
  ::std::string* deviceinfo_;
  ::std::string* ipaddress_;
  ::std::string* country_;
  ::std::string* language_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_initialize_2eproto();
  friend void protobuf_AssignDesc_initialize_2eproto();
  friend void protobuf_ShutdownFile_initialize_2eproto();

  void InitAsDefaultInstance();
  static BINInitializeRequest* default_instance_;
};
// -------------------------------------------------------------------

class BINLevel : public ::google::protobuf::Message {
 public:
  BINLevel();
  virtual ~BINLevel();

  BINLevel(const BINLevel& from);

  inline BINLevel& operator=(const BINLevel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BINLevel& default_instance();

  void Swap(BINLevel* other);

  // implements Message ----------------------------------------------

  BINLevel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BINLevel& from);
  void MergeFrom(const BINLevel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int64 cashGift = 3;
  inline bool has_cashgift() const;
  inline void clear_cashgift();
  static const int kCashGiftFieldNumber = 3;
  inline ::google::protobuf::int64 cashgift() const;
  inline void set_cashgift(::google::protobuf::int64 value);

  // optional int64 goldGift = 4;
  inline bool has_goldgift() const;
  inline void clear_goldgift();
  static const int kGoldGiftFieldNumber = 4;
  inline ::google::protobuf::int64 goldgift() const;
  inline void set_goldgift(::google::protobuf::int64 value);

  // required int64 exp = 5;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 5;
  inline ::google::protobuf::int64 exp() const;
  inline void set_exp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:BINLevel)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_cashgift();
  inline void clear_has_cashgift();
  inline void set_has_goldgift();
  inline void clear_has_goldgift();
  inline void set_has_exp();
  inline void clear_has_exp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int64 cashgift_;
  ::google::protobuf::int64 goldgift_;
  ::google::protobuf::int64 exp_;
  ::google::protobuf::int32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_initialize_2eproto();
  friend void protobuf_AssignDesc_initialize_2eproto();
  friend void protobuf_ShutdownFile_initialize_2eproto();

  void InitAsDefaultInstance();
  static BINLevel* default_instance_;
};
// -------------------------------------------------------------------

class BINInitializeResponse : public ::google::protobuf::Message {
 public:
  BINInitializeResponse();
  virtual ~BINInitializeResponse();

  BINInitializeResponse(const BINInitializeResponse& from);

  inline BINInitializeResponse& operator=(const BINInitializeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BINInitializeResponse& default_instance();

  void Swap(BINInitializeResponse* other);

  // implements Message ----------------------------------------------

  BINInitializeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BINInitializeResponse& from);
  void MergeFrom(const BINInitializeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool responseCode = 1;
  inline bool has_responsecode() const;
  inline void clear_responsecode();
  static const int kResponseCodeFieldNumber = 1;
  inline bool responsecode() const;
  inline void set_responsecode(bool value);

  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // required string currentAppVersion = 3;
  inline bool has_currentappversion() const;
  inline void clear_currentappversion();
  static const int kCurrentAppVersionFieldNumber = 3;
  inline const ::std::string& currentappversion() const;
  inline void set_currentappversion(const ::std::string& value);
  inline void set_currentappversion(const char* value);
  inline void set_currentappversion(const char* value, size_t size);
  inline ::std::string* mutable_currentappversion();
  inline ::std::string* release_currentappversion();
  inline void set_allocated_currentappversion(::std::string* currentappversion);

  // repeated .BINLevel levelDirectory = 4;
  inline int leveldirectory_size() const;
  inline void clear_leveldirectory();
  static const int kLevelDirectoryFieldNumber = 4;
  inline const ::BINLevel& leveldirectory(int index) const;
  inline ::BINLevel* mutable_leveldirectory(int index);
  inline ::BINLevel* add_leveldirectory();
  inline const ::google::protobuf::RepeatedPtrField< ::BINLevel >&
      leveldirectory() const;
  inline ::google::protobuf::RepeatedPtrField< ::BINLevel >*
      mutable_leveldirectory();

  // optional string downloadUrl = 5;
  inline bool has_downloadurl() const;
  inline void clear_downloadurl();
  static const int kDownloadUrlFieldNumber = 5;
  inline const ::std::string& downloadurl() const;
  inline void set_downloadurl(const ::std::string& value);
  inline void set_downloadurl(const char* value);
  inline void set_downloadurl(const char* value, size_t size);
  inline ::std::string* mutable_downloadurl();
  inline ::std::string* release_downloadurl();
  inline void set_allocated_downloadurl(::std::string* downloadurl);

  // optional string cashCurrency = 6;
  inline bool has_cashcurrency() const;
  inline void clear_cashcurrency();
  static const int kCashCurrencyFieldNumber = 6;
  inline const ::std::string& cashcurrency() const;
  inline void set_cashcurrency(const ::std::string& value);
  inline void set_cashcurrency(const char* value);
  inline void set_cashcurrency(const char* value, size_t size);
  inline ::std::string* mutable_cashcurrency();
  inline ::std::string* release_cashcurrency();
  inline void set_allocated_cashcurrency(::std::string* cashcurrency);

  // optional string goldCurrency = 7;
  inline bool has_goldcurrency() const;
  inline void clear_goldcurrency();
  static const int kGoldCurrencyFieldNumber = 7;
  inline const ::std::string& goldcurrency() const;
  inline void set_goldcurrency(const ::std::string& value);
  inline void set_goldcurrency(const char* value);
  inline void set_goldcurrency(const char* value, size_t size);
  inline ::std::string* mutable_goldcurrency();
  inline ::std::string* release_goldcurrency();
  inline void set_allocated_goldcurrency(::std::string* goldcurrency);

  // required bool forceUpdate = 8;
  inline bool has_forceupdate() const;
  inline void clear_forceupdate();
  static const int kForceUpdateFieldNumber = 8;
  inline bool forceupdate() const;
  inline void set_forceupdate(bool value);

  // required bool enableQuickPlay = 9;
  inline bool has_enablequickplay() const;
  inline void clear_enablequickplay();
  static const int kEnableQuickPlayFieldNumber = 9;
  inline bool enablequickplay() const;
  inline void set_enablequickplay(bool value);

  // required bool enableCashSystem = 10;
  inline bool has_enablecashsystem() const;
  inline void clear_enablecashsystem();
  static const int kEnableCashSystemFieldNumber = 10;
  inline bool enablecashsystem() const;
  inline void set_enablecashsystem(bool value);

  // @@protoc_insertion_point(class_scope:BINInitializeResponse)
 private:
  inline void set_has_responsecode();
  inline void clear_has_responsecode();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_currentappversion();
  inline void clear_has_currentappversion();
  inline void set_has_downloadurl();
  inline void clear_has_downloadurl();
  inline void set_has_cashcurrency();
  inline void clear_has_cashcurrency();
  inline void set_has_goldcurrency();
  inline void clear_has_goldcurrency();
  inline void set_has_forceupdate();
  inline void clear_has_forceupdate();
  inline void set_has_enablequickplay();
  inline void clear_has_enablequickplay();
  inline void set_has_enablecashsystem();
  inline void clear_has_enablecashsystem();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;
  ::std::string* currentappversion_;
  ::google::protobuf::RepeatedPtrField< ::BINLevel > leveldirectory_;
  ::std::string* downloadurl_;
  ::std::string* cashcurrency_;
  ::std::string* goldcurrency_;
  bool responsecode_;
  bool forceupdate_;
  bool enablequickplay_;
  bool enablecashsystem_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_initialize_2eproto();
  friend void protobuf_AssignDesc_initialize_2eproto();
  friend void protobuf_ShutdownFile_initialize_2eproto();

  void InitAsDefaultInstance();
  static BINInitializeResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// BINInitializeRequest

// optional string cp = 1;
inline bool BINInitializeRequest::has_cp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BINInitializeRequest::set_has_cp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BINInitializeRequest::clear_has_cp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BINInitializeRequest::clear_cp() {
  if (cp_ != &::google::protobuf::internal::kEmptyString) {
    cp_->clear();
  }
  clear_has_cp();
}
inline const ::std::string& BINInitializeRequest::cp() const {
  return *cp_;
}
inline void BINInitializeRequest::set_cp(const ::std::string& value) {
  set_has_cp();
  if (cp_ == &::google::protobuf::internal::kEmptyString) {
    cp_ = new ::std::string;
  }
  cp_->assign(value);
}
inline void BINInitializeRequest::set_cp(const char* value) {
  set_has_cp();
  if (cp_ == &::google::protobuf::internal::kEmptyString) {
    cp_ = new ::std::string;
  }
  cp_->assign(value);
}
inline void BINInitializeRequest::set_cp(const char* value, size_t size) {
  set_has_cp();
  if (cp_ == &::google::protobuf::internal::kEmptyString) {
    cp_ = new ::std::string;
  }
  cp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BINInitializeRequest::mutable_cp() {
  set_has_cp();
  if (cp_ == &::google::protobuf::internal::kEmptyString) {
    cp_ = new ::std::string;
  }
  return cp_;
}
inline ::std::string* BINInitializeRequest::release_cp() {
  clear_has_cp();
  if (cp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cp_;
    cp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BINInitializeRequest::set_allocated_cp(::std::string* cp) {
  if (cp_ != &::google::protobuf::internal::kEmptyString) {
    delete cp_;
  }
  if (cp) {
    set_has_cp();
    cp_ = cp;
  } else {
    clear_has_cp();
    cp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string appVersion = 2;
inline bool BINInitializeRequest::has_appversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BINInitializeRequest::set_has_appversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BINInitializeRequest::clear_has_appversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BINInitializeRequest::clear_appversion() {
  if (appversion_ != &::google::protobuf::internal::kEmptyString) {
    appversion_->clear();
  }
  clear_has_appversion();
}
inline const ::std::string& BINInitializeRequest::appversion() const {
  return *appversion_;
}
inline void BINInitializeRequest::set_appversion(const ::std::string& value) {
  set_has_appversion();
  if (appversion_ == &::google::protobuf::internal::kEmptyString) {
    appversion_ = new ::std::string;
  }
  appversion_->assign(value);
}
inline void BINInitializeRequest::set_appversion(const char* value) {
  set_has_appversion();
  if (appversion_ == &::google::protobuf::internal::kEmptyString) {
    appversion_ = new ::std::string;
  }
  appversion_->assign(value);
}
inline void BINInitializeRequest::set_appversion(const char* value, size_t size) {
  set_has_appversion();
  if (appversion_ == &::google::protobuf::internal::kEmptyString) {
    appversion_ = new ::std::string;
  }
  appversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BINInitializeRequest::mutable_appversion() {
  set_has_appversion();
  if (appversion_ == &::google::protobuf::internal::kEmptyString) {
    appversion_ = new ::std::string;
  }
  return appversion_;
}
inline ::std::string* BINInitializeRequest::release_appversion() {
  clear_has_appversion();
  if (appversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appversion_;
    appversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BINInitializeRequest::set_allocated_appversion(::std::string* appversion) {
  if (appversion_ != &::google::protobuf::internal::kEmptyString) {
    delete appversion_;
  }
  if (appversion) {
    set_has_appversion();
    appversion_ = appversion;
  } else {
    clear_has_appversion();
    appversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceId = 3;
inline bool BINInitializeRequest::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BINInitializeRequest::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BINInitializeRequest::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BINInitializeRequest::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& BINInitializeRequest::deviceid() const {
  return *deviceid_;
}
inline void BINInitializeRequest::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void BINInitializeRequest::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void BINInitializeRequest::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BINInitializeRequest::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* BINInitializeRequest::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BINInitializeRequest::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceInfo = 4;
inline bool BINInitializeRequest::has_deviceinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BINInitializeRequest::set_has_deviceinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BINInitializeRequest::clear_has_deviceinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BINInitializeRequest::clear_deviceinfo() {
  if (deviceinfo_ != &::google::protobuf::internal::kEmptyString) {
    deviceinfo_->clear();
  }
  clear_has_deviceinfo();
}
inline const ::std::string& BINInitializeRequest::deviceinfo() const {
  return *deviceinfo_;
}
inline void BINInitializeRequest::set_deviceinfo(const ::std::string& value) {
  set_has_deviceinfo();
  if (deviceinfo_ == &::google::protobuf::internal::kEmptyString) {
    deviceinfo_ = new ::std::string;
  }
  deviceinfo_->assign(value);
}
inline void BINInitializeRequest::set_deviceinfo(const char* value) {
  set_has_deviceinfo();
  if (deviceinfo_ == &::google::protobuf::internal::kEmptyString) {
    deviceinfo_ = new ::std::string;
  }
  deviceinfo_->assign(value);
}
inline void BINInitializeRequest::set_deviceinfo(const char* value, size_t size) {
  set_has_deviceinfo();
  if (deviceinfo_ == &::google::protobuf::internal::kEmptyString) {
    deviceinfo_ = new ::std::string;
  }
  deviceinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BINInitializeRequest::mutable_deviceinfo() {
  set_has_deviceinfo();
  if (deviceinfo_ == &::google::protobuf::internal::kEmptyString) {
    deviceinfo_ = new ::std::string;
  }
  return deviceinfo_;
}
inline ::std::string* BINInitializeRequest::release_deviceinfo() {
  clear_has_deviceinfo();
  if (deviceinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceinfo_;
    deviceinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BINInitializeRequest::set_allocated_deviceinfo(::std::string* deviceinfo) {
  if (deviceinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceinfo_;
  }
  if (deviceinfo) {
    set_has_deviceinfo();
    deviceinfo_ = deviceinfo;
  } else {
    clear_has_deviceinfo();
    deviceinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ipAddress = 5;
inline bool BINInitializeRequest::has_ipaddress() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BINInitializeRequest::set_has_ipaddress() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BINInitializeRequest::clear_has_ipaddress() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BINInitializeRequest::clear_ipaddress() {
  if (ipaddress_ != &::google::protobuf::internal::kEmptyString) {
    ipaddress_->clear();
  }
  clear_has_ipaddress();
}
inline const ::std::string& BINInitializeRequest::ipaddress() const {
  return *ipaddress_;
}
inline void BINInitializeRequest::set_ipaddress(const ::std::string& value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
}
inline void BINInitializeRequest::set_ipaddress(const char* value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
}
inline void BINInitializeRequest::set_ipaddress(const char* value, size_t size) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BINInitializeRequest::mutable_ipaddress() {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  return ipaddress_;
}
inline ::std::string* BINInitializeRequest::release_ipaddress() {
  clear_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipaddress_;
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BINInitializeRequest::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete ipaddress_;
  }
  if (ipaddress) {
    set_has_ipaddress();
    ipaddress_ = ipaddress;
  } else {
    clear_has_ipaddress();
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string country = 6;
inline bool BINInitializeRequest::has_country() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BINInitializeRequest::set_has_country() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BINInitializeRequest::clear_has_country() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BINInitializeRequest::clear_country() {
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& BINInitializeRequest::country() const {
  return *country_;
}
inline void BINInitializeRequest::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void BINInitializeRequest::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void BINInitializeRequest::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BINInitializeRequest::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  return country_;
}
inline ::std::string* BINInitializeRequest::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BINInitializeRequest::set_allocated_country(::std::string* country) {
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    delete country_;
  }
  if (country) {
    set_has_country();
    country_ = country;
  } else {
    clear_has_country();
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string language = 7;
inline bool BINInitializeRequest::has_language() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BINInitializeRequest::set_has_language() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BINInitializeRequest::clear_has_language() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BINInitializeRequest::clear_language() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& BINInitializeRequest::language() const {
  return *language_;
}
inline void BINInitializeRequest::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void BINInitializeRequest::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void BINInitializeRequest::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BINInitializeRequest::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  return language_;
}
inline ::std::string* BINInitializeRequest::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BINInitializeRequest::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BINLevel

// required int32 level = 1;
inline bool BINLevel::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BINLevel::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BINLevel::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BINLevel::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 BINLevel::level() const {
  return level_;
}
inline void BINLevel::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required string name = 2;
inline bool BINLevel::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BINLevel::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BINLevel::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BINLevel::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& BINLevel::name() const {
  return *name_;
}
inline void BINLevel::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BINLevel::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BINLevel::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BINLevel::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* BINLevel::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BINLevel::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 cashGift = 3;
inline bool BINLevel::has_cashgift() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BINLevel::set_has_cashgift() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BINLevel::clear_has_cashgift() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BINLevel::clear_cashgift() {
  cashgift_ = GOOGLE_LONGLONG(0);
  clear_has_cashgift();
}
inline ::google::protobuf::int64 BINLevel::cashgift() const {
  return cashgift_;
}
inline void BINLevel::set_cashgift(::google::protobuf::int64 value) {
  set_has_cashgift();
  cashgift_ = value;
}

// optional int64 goldGift = 4;
inline bool BINLevel::has_goldgift() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BINLevel::set_has_goldgift() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BINLevel::clear_has_goldgift() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BINLevel::clear_goldgift() {
  goldgift_ = GOOGLE_LONGLONG(0);
  clear_has_goldgift();
}
inline ::google::protobuf::int64 BINLevel::goldgift() const {
  return goldgift_;
}
inline void BINLevel::set_goldgift(::google::protobuf::int64 value) {
  set_has_goldgift();
  goldgift_ = value;
}

// required int64 exp = 5;
inline bool BINLevel::has_exp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BINLevel::set_has_exp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BINLevel::clear_has_exp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BINLevel::clear_exp() {
  exp_ = GOOGLE_LONGLONG(0);
  clear_has_exp();
}
inline ::google::protobuf::int64 BINLevel::exp() const {
  return exp_;
}
inline void BINLevel::set_exp(::google::protobuf::int64 value) {
  set_has_exp();
  exp_ = value;
}

// -------------------------------------------------------------------

// BINInitializeResponse

// required bool responseCode = 1;
inline bool BINInitializeResponse::has_responsecode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BINInitializeResponse::set_has_responsecode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BINInitializeResponse::clear_has_responsecode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BINInitializeResponse::clear_responsecode() {
  responsecode_ = false;
  clear_has_responsecode();
}
inline bool BINInitializeResponse::responsecode() const {
  return responsecode_;
}
inline void BINInitializeResponse::set_responsecode(bool value) {
  set_has_responsecode();
  responsecode_ = value;
}

// optional string message = 2;
inline bool BINInitializeResponse::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BINInitializeResponse::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BINInitializeResponse::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BINInitializeResponse::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& BINInitializeResponse::message() const {
  return *message_;
}
inline void BINInitializeResponse::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void BINInitializeResponse::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void BINInitializeResponse::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BINInitializeResponse::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* BINInitializeResponse::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BINInitializeResponse::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string currentAppVersion = 3;
inline bool BINInitializeResponse::has_currentappversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BINInitializeResponse::set_has_currentappversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BINInitializeResponse::clear_has_currentappversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BINInitializeResponse::clear_currentappversion() {
  if (currentappversion_ != &::google::protobuf::internal::kEmptyString) {
    currentappversion_->clear();
  }
  clear_has_currentappversion();
}
inline const ::std::string& BINInitializeResponse::currentappversion() const {
  return *currentappversion_;
}
inline void BINInitializeResponse::set_currentappversion(const ::std::string& value) {
  set_has_currentappversion();
  if (currentappversion_ == &::google::protobuf::internal::kEmptyString) {
    currentappversion_ = new ::std::string;
  }
  currentappversion_->assign(value);
}
inline void BINInitializeResponse::set_currentappversion(const char* value) {
  set_has_currentappversion();
  if (currentappversion_ == &::google::protobuf::internal::kEmptyString) {
    currentappversion_ = new ::std::string;
  }
  currentappversion_->assign(value);
}
inline void BINInitializeResponse::set_currentappversion(const char* value, size_t size) {
  set_has_currentappversion();
  if (currentappversion_ == &::google::protobuf::internal::kEmptyString) {
    currentappversion_ = new ::std::string;
  }
  currentappversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BINInitializeResponse::mutable_currentappversion() {
  set_has_currentappversion();
  if (currentappversion_ == &::google::protobuf::internal::kEmptyString) {
    currentappversion_ = new ::std::string;
  }
  return currentappversion_;
}
inline ::std::string* BINInitializeResponse::release_currentappversion() {
  clear_has_currentappversion();
  if (currentappversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currentappversion_;
    currentappversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BINInitializeResponse::set_allocated_currentappversion(::std::string* currentappversion) {
  if (currentappversion_ != &::google::protobuf::internal::kEmptyString) {
    delete currentappversion_;
  }
  if (currentappversion) {
    set_has_currentappversion();
    currentappversion_ = currentappversion;
  } else {
    clear_has_currentappversion();
    currentappversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .BINLevel levelDirectory = 4;
inline int BINInitializeResponse::leveldirectory_size() const {
  return leveldirectory_.size();
}
inline void BINInitializeResponse::clear_leveldirectory() {
  leveldirectory_.Clear();
}
inline const ::BINLevel& BINInitializeResponse::leveldirectory(int index) const {
  return leveldirectory_.Get(index);
}
inline ::BINLevel* BINInitializeResponse::mutable_leveldirectory(int index) {
  return leveldirectory_.Mutable(index);
}
inline ::BINLevel* BINInitializeResponse::add_leveldirectory() {
  return leveldirectory_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BINLevel >&
BINInitializeResponse::leveldirectory() const {
  return leveldirectory_;
}
inline ::google::protobuf::RepeatedPtrField< ::BINLevel >*
BINInitializeResponse::mutable_leveldirectory() {
  return &leveldirectory_;
}

// optional string downloadUrl = 5;
inline bool BINInitializeResponse::has_downloadurl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BINInitializeResponse::set_has_downloadurl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BINInitializeResponse::clear_has_downloadurl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BINInitializeResponse::clear_downloadurl() {
  if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
    downloadurl_->clear();
  }
  clear_has_downloadurl();
}
inline const ::std::string& BINInitializeResponse::downloadurl() const {
  return *downloadurl_;
}
inline void BINInitializeResponse::set_downloadurl(const ::std::string& value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void BINInitializeResponse::set_downloadurl(const char* value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void BINInitializeResponse::set_downloadurl(const char* value, size_t size) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BINInitializeResponse::mutable_downloadurl() {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  return downloadurl_;
}
inline ::std::string* BINInitializeResponse::release_downloadurl() {
  clear_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = downloadurl_;
    downloadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BINInitializeResponse::set_allocated_downloadurl(::std::string* downloadurl) {
  if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
    delete downloadurl_;
  }
  if (downloadurl) {
    set_has_downloadurl();
    downloadurl_ = downloadurl;
  } else {
    clear_has_downloadurl();
    downloadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cashCurrency = 6;
inline bool BINInitializeResponse::has_cashcurrency() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BINInitializeResponse::set_has_cashcurrency() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BINInitializeResponse::clear_has_cashcurrency() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BINInitializeResponse::clear_cashcurrency() {
  if (cashcurrency_ != &::google::protobuf::internal::kEmptyString) {
    cashcurrency_->clear();
  }
  clear_has_cashcurrency();
}
inline const ::std::string& BINInitializeResponse::cashcurrency() const {
  return *cashcurrency_;
}
inline void BINInitializeResponse::set_cashcurrency(const ::std::string& value) {
  set_has_cashcurrency();
  if (cashcurrency_ == &::google::protobuf::internal::kEmptyString) {
    cashcurrency_ = new ::std::string;
  }
  cashcurrency_->assign(value);
}
inline void BINInitializeResponse::set_cashcurrency(const char* value) {
  set_has_cashcurrency();
  if (cashcurrency_ == &::google::protobuf::internal::kEmptyString) {
    cashcurrency_ = new ::std::string;
  }
  cashcurrency_->assign(value);
}
inline void BINInitializeResponse::set_cashcurrency(const char* value, size_t size) {
  set_has_cashcurrency();
  if (cashcurrency_ == &::google::protobuf::internal::kEmptyString) {
    cashcurrency_ = new ::std::string;
  }
  cashcurrency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BINInitializeResponse::mutable_cashcurrency() {
  set_has_cashcurrency();
  if (cashcurrency_ == &::google::protobuf::internal::kEmptyString) {
    cashcurrency_ = new ::std::string;
  }
  return cashcurrency_;
}
inline ::std::string* BINInitializeResponse::release_cashcurrency() {
  clear_has_cashcurrency();
  if (cashcurrency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cashcurrency_;
    cashcurrency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BINInitializeResponse::set_allocated_cashcurrency(::std::string* cashcurrency) {
  if (cashcurrency_ != &::google::protobuf::internal::kEmptyString) {
    delete cashcurrency_;
  }
  if (cashcurrency) {
    set_has_cashcurrency();
    cashcurrency_ = cashcurrency;
  } else {
    clear_has_cashcurrency();
    cashcurrency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string goldCurrency = 7;
inline bool BINInitializeResponse::has_goldcurrency() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BINInitializeResponse::set_has_goldcurrency() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BINInitializeResponse::clear_has_goldcurrency() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BINInitializeResponse::clear_goldcurrency() {
  if (goldcurrency_ != &::google::protobuf::internal::kEmptyString) {
    goldcurrency_->clear();
  }
  clear_has_goldcurrency();
}
inline const ::std::string& BINInitializeResponse::goldcurrency() const {
  return *goldcurrency_;
}
inline void BINInitializeResponse::set_goldcurrency(const ::std::string& value) {
  set_has_goldcurrency();
  if (goldcurrency_ == &::google::protobuf::internal::kEmptyString) {
    goldcurrency_ = new ::std::string;
  }
  goldcurrency_->assign(value);
}
inline void BINInitializeResponse::set_goldcurrency(const char* value) {
  set_has_goldcurrency();
  if (goldcurrency_ == &::google::protobuf::internal::kEmptyString) {
    goldcurrency_ = new ::std::string;
  }
  goldcurrency_->assign(value);
}
inline void BINInitializeResponse::set_goldcurrency(const char* value, size_t size) {
  set_has_goldcurrency();
  if (goldcurrency_ == &::google::protobuf::internal::kEmptyString) {
    goldcurrency_ = new ::std::string;
  }
  goldcurrency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BINInitializeResponse::mutable_goldcurrency() {
  set_has_goldcurrency();
  if (goldcurrency_ == &::google::protobuf::internal::kEmptyString) {
    goldcurrency_ = new ::std::string;
  }
  return goldcurrency_;
}
inline ::std::string* BINInitializeResponse::release_goldcurrency() {
  clear_has_goldcurrency();
  if (goldcurrency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = goldcurrency_;
    goldcurrency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BINInitializeResponse::set_allocated_goldcurrency(::std::string* goldcurrency) {
  if (goldcurrency_ != &::google::protobuf::internal::kEmptyString) {
    delete goldcurrency_;
  }
  if (goldcurrency) {
    set_has_goldcurrency();
    goldcurrency_ = goldcurrency;
  } else {
    clear_has_goldcurrency();
    goldcurrency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool forceUpdate = 8;
inline bool BINInitializeResponse::has_forceupdate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BINInitializeResponse::set_has_forceupdate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BINInitializeResponse::clear_has_forceupdate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BINInitializeResponse::clear_forceupdate() {
  forceupdate_ = false;
  clear_has_forceupdate();
}
inline bool BINInitializeResponse::forceupdate() const {
  return forceupdate_;
}
inline void BINInitializeResponse::set_forceupdate(bool value) {
  set_has_forceupdate();
  forceupdate_ = value;
}

// required bool enableQuickPlay = 9;
inline bool BINInitializeResponse::has_enablequickplay() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BINInitializeResponse::set_has_enablequickplay() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BINInitializeResponse::clear_has_enablequickplay() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BINInitializeResponse::clear_enablequickplay() {
  enablequickplay_ = false;
  clear_has_enablequickplay();
}
inline bool BINInitializeResponse::enablequickplay() const {
  return enablequickplay_;
}
inline void BINInitializeResponse::set_enablequickplay(bool value) {
  set_has_enablequickplay();
  enablequickplay_ = value;
}

// required bool enableCashSystem = 10;
inline bool BINInitializeResponse::has_enablecashsystem() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BINInitializeResponse::set_has_enablecashsystem() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BINInitializeResponse::clear_has_enablecashsystem() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BINInitializeResponse::clear_enablecashsystem() {
  enablecashsystem_ = false;
  clear_has_enablecashsystem();
}
inline bool BINInitializeResponse::enablecashsystem() const {
  return enablecashsystem_;
}
inline void BINInitializeResponse::set_enablecashsystem(bool value) {
  set_has_enablecashsystem();
  enablecashsystem_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_initialize_2eproto__INCLUDED
